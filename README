The input command of an user in a shell-type program can be quite complex, so in order to simplify the process it can be broken down into several steps each represented by the correspoding .c and .h file.

The Process header file contains a structure which hold the input given by the user in a parsed buffer form, the number of processes and all the various commands to be executed along with their corresponding parameters.

The CommandList header file similarly contains a strucuture to hold he number of programs to be executed, FDs for input and output which might be different from the standard input/output ones, a series of programs to be executed and a field for a any potential error code.

The Program header file contains a strucutre to hold the number of parameters per command to be executed, along with an array with the corresponding paramters. Additionally, the structure Program also contains a set of pipes in the event that the input/output is being piped from/to another program.

A Process can contain one or more CommandLists, which in turn can contain one or more Programs. Each of the described structures is used in a class-like fashion where each strucutre contains functions to change the above described fields. A Process has functions to run/free a process and to add new CommandLists. A CommandList can run/free a commandList and can add a program to its set of programs. A Program can run/free a program, add a parameter to a program and set the pipes for a given program.

This sort of abstraction of the process at different levels allows for better control over each of the steps. A Program is only concerned with running a given command with its parameters and controls only such behavior, while a CommandList has a set of Programs to run and controls the input/output behavior of said set etc.

The parsing of a single input line from the user at all the different levels is handled by Parsing.c.

== I/O REDIRECTION ==

With the above described structure it is easy to see how the input/ouput redirection can be handled. The I/O behavior is handled by CommandList, as it has two fields named in_fd and out_fd for inputs and outputs accordingly. Once the input line from the user has been read it can be searched for the symbols signifying I/O redirection namely '<' and '>'. If either of the two symbols (or both of them) are detected the file name after the correspodning symbol is used to obtain the FD of said file. If no file name an error is thrown. Once the FD(s) have been obtained simply the fields in_fd and out_fd need to be set to the obtained value. If no I/O redirection symbols are detected in_fd and out_fd remain unchainged as their default falues are 0 (stdin) and 1 (stdout) accordingly.

== BACKGROUND PROCESSES ==

With the described structure the way background processes are implemented is the following: if the '&' symbol is detected the parent spawns a child, that child in turn spawns another child which executed the command. In order to prevent the blocking of the parent the wait() is used with the parameter WNOHANG, which means the shell remains open for new commands. The reason behind implementing background processes in such a manner and spawning a child which spawns a child is that once the command has been executed some cleaning up has to be done. That is memory needs to be freed once the execution of the command has terminated. That is done by the first child which is decoupled from the parent, leading to the running-in-the-background behavior. 